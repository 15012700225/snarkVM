// Copyright (C) 2019-2022 Aleo Systems Inc.
// This file is part of the snarkVM library.

// The snarkVM library is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The snarkVM library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with the snarkVM library. If not, see <https://www.gnu.org/licenses/>.

use snarkvm_curves::AffineCurve;
use snarkvm_fields::{PrimeField, Zero};
use snarkvm_utilities::rand::UniformRand;

use rand::Rng;
use std::{
    collections::HashMap,
    ops::{Add, Mul},
};

/// The public key used to verify a threshold signature made by a group of signers.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct GroupPublicKey<G: AffineCurve>(pub G);

/// The signer's public key.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerPublicKey<G: AffineCurve>(pub G);

/// The signer's secret key
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerSecretKey<G: AffineCurve>(pub <G as AffineCurve>::ScalarField);

/// The list of signer public keys and the group public key.
pub struct PublicKeys<G: AffineCurve> {
    /// The map of all participant public keys.
    pub public_keys: HashMap<u64, SignerPublicKey<G>>,
    /// The group public key used to verify the final threshold signature.
    pub group_public_key: GroupPublicKey<G>,
}

/// A signer's share that includes its secret key and all publicly known keys/commitments.
pub struct SignerShare<G: AffineCurve> {
    /// The index of the participant.
    pub participant_index: u64,
    /// The participant's public key.
    pub public_key: SignerPublicKey<G>,
    /// The participant's secret key share.
    pub secret_key: SignerSecretKey<G>,
    /// The group public key used to verify the final threshold signature.
    pub group_public_key: GroupPublicKey<G>,
    /// This is the public commitments to the coefficients generated by each participant.
    pub commitment: Vec<G>,
}

impl<G: AffineCurve> SignerShare<G> {
    /// Verify that the secret share was generated correctly and matches the commitment.
    pub fn is_valid(&self) -> bool {
        let expected_result = G::prime_subgroup_generator().mul(self.secret_key.0);

        let index_scalar = <G as AffineCurve>::ScalarField::from_repr((self.participant_index as u64).into()).unwrap();
        let mut result = G::zero().to_projective();
        for (i, c) in self.commitment.iter().rev().enumerate() {
            result = result.add(c.to_projective());

            if i != self.commitment.len() - 1 {
                result = result.mul(index_scalar);
            }
        }

        expected_result == result.into()
    }
}

/// Generate the participant keys using a trusted authority, a dealer. This can be done with
/// DKG, but for simplicity we will use a trusted dealer model. This trusted dealer model only
/// generates a single polynomial for all participants, and then uses the indexes to determine
/// secret shares for each participant.
pub fn trusted_keygen<R: Rng, G: AffineCurve>(
    num_participants: u8,
    threshold: u8,
    rng: &mut R,
) -> (Vec<SignerShare<G>>, PublicKeys<G>) {
    if num_participants < 1 {
        panic!("The number of participants must be greater than 0.");
    }

    if threshold < 1 || threshold > num_participants {
        panic!("threshold must be between 1 and num_participants");
    }

    let mut coefficients: Vec<<G as AffineCurve>::ScalarField> = Vec::with_capacity(threshold as usize);
    let mut share_commitment: Vec<G> = Vec::with_capacity(threshold as usize);

    // Sample the `secret`where g^`secret` = GroupPublicKey.
    let secret = <G as AffineCurve>::ScalarField::rand(rng);

    // FROST KeyGen Round 1.1: Generate the polynomial coefficients.
    coefficients.push(secret);
    for _ in 0..threshold - 1 {
        coefficients.push(<G as AffineCurve>::ScalarField::rand(rng));
    }

    // TODO (raychu86): Generate the proof of knowledge of the very first coefficient.

    // FROST KeyGen Round 1.3: Generate the public commitments.
    for coeff in &coefficients {
        share_commitment.push(G::prime_subgroup_generator().mul(*coeff).into());
    }

    // Generate the group secret key from the provided secret.
    let group_public_key = GroupPublicKey(G::prime_subgroup_generator().mul(secret).into());

    // FROST KeyGen Round 2: Generate the secret shares for each participant using a centralized authority.
    // As described in https://github.com/isislovecruft/frost-dalek/blob/main/src/keygen.rs
    let mut shares = Vec::with_capacity(num_participants as usize);
    let mut participant_public_keys: HashMap<u64, SignerPublicKey<G>> =
        HashMap::with_capacity(num_participants as usize);

    for index in 1..num_participants + 1 {
        // Evaluate the polynomial at point `index`.
        let index_scalar = <G as AffineCurve>::ScalarField::from_repr((index as u64).into()).unwrap();
        let mut result = <G as AffineCurve>::ScalarField::zero();
        for (i, coeff) in coefficients.iter().rev().enumerate() {
            result += coeff;

            if i != coefficients.len() - 1 {
                result *= index_scalar;
            }
        }

        let public_key = SignerPublicKey(G::prime_subgroup_generator().mul(result).into());

        let secret_share = SignerShare {
            participant_index: index as u64,
            public_key: public_key.clone(),
            secret_key: SignerSecretKey(result),
            group_public_key: group_public_key.clone(),
            commitment: share_commitment.clone(),
        };

        participant_public_keys.insert(index as u64, public_key);
        shares.push(secret_share);
    }

    let public_keys = PublicKeys { public_keys: participant_public_keys, group_public_key };

    (shares, public_keys)
}

#[cfg(test)]
mod test {
    use super::*;

    use snarkvm_curves::edwards_bls12::EdwardsAffine as EdwardsBls12Affine;
    use snarkvm_utilities::test_rng;

    #[test]
    fn test_single_participant_trusted_keygen() {
        let mut rng = test_rng();

        let threshold = 1;
        let num_participants = 1;

        let (shares, public_keys) = trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &mut rng);

        assert_eq!(shares.len(), num_participants as usize);
        assert_eq!(public_keys.public_keys.len(), num_participants as usize);

        for (index, share) in shares.iter().enumerate() {
            assert_eq!(share.participant_index, index as u64 + 1);
            assert_eq!(share.group_public_key.0, public_keys.group_public_key.0);
            assert_eq!(share.commitment.len(), threshold as usize);
            assert!(share.is_valid());
        }
    }

    #[test]
    fn test_3_out_of_5_trusted_keygen() {
        let mut rng = test_rng();

        let threshold = 3;
        let num_participants = 5;

        let (shares, public_keys) = trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &mut rng);

        assert_eq!(shares.len(), num_participants as usize);
        assert_eq!(public_keys.public_keys.len(), num_participants as usize);

        for (index, share) in shares.iter().enumerate() {
            assert_eq!(share.participant_index, index as u64 + 1);
            assert_eq!(share.group_public_key.0, public_keys.group_public_key.0);
            assert_eq!(share.commitment.len(), threshold as usize);
            assert!(share.is_valid());
        }
    }

    #[test]
    fn test_6_out_of_10_trusted_keygen() {
        let mut rng = test_rng();

        let threshold = 3;
        let num_participants = 5;

        let (shares, public_keys) = trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &mut rng);

        assert_eq!(shares.len(), num_participants as usize);
        assert_eq!(public_keys.public_keys.len(), num_participants as usize);

        for (index, share) in shares.iter().enumerate() {
            assert_eq!(share.participant_index, index as u64 + 1);
            assert_eq!(share.group_public_key.0, public_keys.group_public_key.0);
            assert_eq!(share.commitment.len(), threshold as usize);
            assert!(share.is_valid());
        }
    }

    // TODO (raychu86): Test secret reconstruction using lagrange coefficients.
}
